#pragma once

namespace AutoGenerated
{ 
    struct ShaderData;
}

// Must be exactly the same as in the ShaderCompiler
enum GfxShaderType { VS, PS, CS };

class GfxShader
{
public:
    ID3DBlob* GetBlob() const { return m_ShaderBlob.Get(); }
    std::size_t GetHash() const { return m_Hash; }

protected:
    void Initialize(const AutoGenerated::ShaderData&);

    ComPtr<ID3DBlob> m_ShaderBlob;
    std::size_t m_Hash = 0;

    friend class GfxShaderManager;
};

class GfxShaderManager
{
public:
    DeclareSingletonFunctions(GfxShaderManager);

    void Initialize(tf::Subflow& sf);

    template <typename ShaderPermutations>
    const GfxShader& GetShader(const ShaderPermutations& permutations)
    {
        return GetShaderContainer<ShaderPermutations::ShaderType>().at(ShaderPermutations::BaseShaderID).at(permutations.m_ShaderKey);
    }

private:

    // key == BaseShaderID, val = { ShaderKey, GfxShader }
    using ShaderContainer = std::unordered_map<uint32_t, std::unordered_map<uint32_t, GfxShader>>;

    template <GfxShaderType ShaderType>
    ShaderContainer& GetShaderContainer();

    template <> ShaderContainer& GetShaderContainer<(uint32_t)VS>(){ return m_AllVSShaders; };
    template <> ShaderContainer& GetShaderContainer<(uint32_t)PS>(){ return m_AllPSShaders; };

    ShaderContainer m_AllVSShaders;
    ShaderContainer m_AllPSShaders;
};
#define g_GfxShaderManager GfxShaderManager::GetInstance()
