#include <graphic/gfx/gfxshadermanager.h>
#include <graphic/pch.h>

#include <tmp/shaders/shaderbytecodes.h>

void GfxShader::Initialize(const AutoGenerated::ShaderData& data)
{
    bbeProfileFunction();
    assert(m_ShaderBlob == nullptr);
    assert(m_Hash == 0);
    assert(data.m_ByteCodeArray != nullptr);
    assert(data.m_ByteCodeSize > 0);

    DX12_CALL(D3DCreateBlob(data.m_ByteCodeSize, &m_ShaderBlob));
    memcpy(m_ShaderBlob->GetBufferPointer(), data.m_ByteCodeArray, data.m_ByteCodeSize);

    m_Type = data.m_ShaderType;

    assert(m_Hash == 0);
    m_Hash = boost::hash_range(data.m_ByteCodeArray, data.m_ByteCodeArray + data.m_ByteCodeSize);
}

void GfxShaderManager::Initialize()
{
    bbeProfileFunction();

    // init blank GfxShaders before doing the real MT init
    for (const AutoGenerated::ShaderData& data : AutoGenerated::gs_AllShadersData)
    {
        m_ShaderContainers[data.m_ShaderType][data.m_BaseShaderID][data.m_ShaderKey];
    }

    for (const AutoGenerated::ShaderData& data : AutoGenerated::gs_AllShadersData)
    {
        g_TasksExecutor.silent_async([this, &data] { m_ShaderContainers[data.m_ShaderType][data.m_BaseShaderID][data.m_ShaderKey].Initialize(data); });
    }
}

template <GfxShaderType Type>
GfxShader& GfxShaderManager::GetNullShader()
{
    static GfxShader s_NullShaders[GfxShaderType_Count] = { {VS}, {PS}, {CS} };
    return s_NullShaders[Type];
}
template GfxShader& GfxShaderManager::GetNullShader<VS>();
template GfxShader& GfxShaderManager::GetNullShader<PS>();
template GfxShader& GfxShaderManager::GetNullShader<CS>();
