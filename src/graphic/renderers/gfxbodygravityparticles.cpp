
#include <graphic/pch.h>

#include <system/imguimanager.h>

#include <tmp/shaders/autogen/cpp/ShaderInputs/NBodyGravityCSConsts.h>
#include <tmp/shaders/autogen/cpp/ShaderInputs/NBodyGravityVSPSConsts.h>
#include <tmp/shaders/autogen/cpp/ShaderInputs/BodyGravityPosVelo.h>
#include <tmp/shaders/autogen/cpp/ShaderPermutations/NBodyGravity.h>

namespace BodyGravityParticles
{
    static bool gs_UpdateIMGUI = false;
    static uint32_t gs_ParticleCount = 500;
    static float gs_ParticleSpread = 50.0f;
    static float gs_ParticlesDamping = 1.0f;
    static float gs_ParticleMass = 66.0f;

    static GfxTexture gs_ParticlesUAV;
}

class GfxBodyGravityParticlesUpdate : public GfxRendererBase
{
    void Initialize() override;
    void PopulateCommandList(GfxContext& context) override;
    bool ShouldPopulateCommandList(GfxContext&) const override { return BodyGravityParticles::gs_UpdateIMGUI; }
    const char* GetName() const override { return "GfxBodyGravityParticlesUpdate"; }

    void InitParticlesUAVBuffer(D3D12GraphicsCommandList* pCommandList = nullptr);

    void UpdateIMGUI();

    GfxRootSignature* m_RootSignature = nullptr;
    bool m_InitUAVBuffer = true;
};

void GfxBodyGravityParticlesUpdate::InitParticlesUAVBuffer(D3D12GraphicsCommandList* pCommandList)
{
    BodyGravityParticles::gs_ParticlesUAV.Release();

    const uint32_t sizeInBytes = BodyGravityParticles::gs_ParticleCount * sizeof(AutoGenerated::BodyGravityPosVelo);

    BodyGravityParticles::gs_ParticlesUAV.InitializeStructuredBuffer<AutoGenerated::BodyGravityPosVelo>(CD3DX12_RESOURCE_DESC1::Buffer(sizeInBytes, D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS), BodyGravityParticles::gs_ParticleCount);
    BodyGravityParticles::gs_ParticlesUAV.SetDebugName("BodyGravityParticles_Buffer");

    std::vector<AutoGenerated::BodyGravityPosVelo> particlesData;
    particlesData.resize(BodyGravityParticles::gs_ParticleCount);

    const float spread = BodyGravityParticles::gs_ParticleSpread;
    const float centerSpread = spread * 0.50f;
    for (uint32_t i = 0; i < particlesData.size(); i++)
    {
        bbeVector3 delta{ spread, spread, spread };

        while (delta.LengthSquared() > spread * spread)
        {
            delta.x = (RandomFloat(2.0f) - 1.0f) * spread;
            delta.y = (RandomFloat(2.0f) - 1.0f) * spread;
            delta.z = (RandomFloat(2.0f) - 1.0f) * spread;
        }

        particlesData[i].m_Pos.x = centerSpread + delta.x;
        particlesData[i].m_Pos.y = centerSpread + delta.y;
        particlesData[i].m_Pos.z = centerSpread + delta.z;
        particlesData[i].m_Pos.w = 0.0f;

        particlesData[i].m_Velocity = bbeVector4{ 0, 0, -20.0f, 0.0f };
    }

    if (!pCommandList)
    {
        GfxCommandList* newCmdList = g_GfxCommandListsManager.GetMainQueue().AllocateCommandList("GfxBodyGravityParticlesUpdate::InitParticlesUAVBuffer");
        g_GfxCommandListsManager.QueueCommandListToExecute(newCmdList);
        pCommandList = newCmdList->Dev();
    }

    UploadToGfxResource(pCommandList, BodyGravityParticles::gs_ParticlesUAV, sizeInBytes, sizeInBytes, sizeInBytes, particlesData.data());

    m_InitUAVBuffer = false;
}

void GfxBodyGravityParticlesUpdate::Initialize()
{
    bbeProfileFunction();

    g_IMGUIManager.RegisterTopMenu("Graphic", GetName(), &BodyGravityParticles::gs_UpdateIMGUI);
    g_IMGUIManager.RegisterWindowUpdateCB([&]() { UpdateIMGUI(); });

    // Perfomance TIP: Order from most frequent to least frequent.
    CD3DX12_DESCRIPTOR_RANGE1 ranges[2]{};
    ranges[0].Init(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, 1, AutoGenerated::NBodyGravityVSPSConsts::ConstantBufferRegister, 0, D3D12_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_VOLATILE);
    ranges[1].Init(D3D12_DESCRIPTOR_RANGE_TYPE_UAV, AutoGenerated::NBodyGravityCSConsts::NbUAVs, 0, 0, D3D12_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_VOLATILE | D3D12_DESCRIPTOR_RANGE_FLAG_DATA_VOLATILE);

    m_RootSignature = g_GfxRootSignatureManager.GetOrCreateRootSig(ranges, D3D12_ROOT_SIGNATURE_FLAG_NONE, "GfxBodyGravityParticlesUpdate_RootSignature");

    InitParticlesUAVBuffer();
}

void GfxBodyGravityParticlesUpdate::PopulateCommandList(GfxContext& context)
{
    constexpr float softeningSquared = 0.0012500000f * 0.0012500000f;

    bbeProfileFunction();
    bbeProfileGPUFunction(context);

    assert(m_RootSignature);
    context.SetRootSignature(*m_RootSignature);

    if (m_InitUAVBuffer)
        InitParticlesUAVBuffer(context.GetCommandList().Dev());

    AutoGenerated::NBodyGravityCSConsts consts;
    consts.m_DeltaTime = (float)g_System.GetFrameTimeMs() / 1000; // seconds
    consts.m_MaxParticles = BodyGravityParticles::gs_ParticleCount;
    consts.m_ParticlesDamping = BodyGravityParticles::gs_ParticlesDamping;
    consts.m_TileSize = uint32_t(std::ceil(consts.m_MaxParticles / AutoGenerated::NBodyGravityCSConsts::BlockSize));
    context.StageCBV(consts);

    context.StageUAV(BodyGravityParticles::gs_ParticlesUAV, 1, AutoGenerated::NBodyGravityCSConsts::UAVOffsets::PosVelo);

    context.SetShader(g_GfxShaderManager.GetShader(Shaders::CS_NBodyGravity{}));
    context.Dispatch(consts.m_TileSize, 1, 1);
}

void GfxBodyGravityParticlesUpdate::UpdateIMGUI()
{
    if (!BodyGravityParticles::gs_UpdateIMGUI)
        return;

    ImGui::SliderFloat("Particles Damping", &BodyGravityParticles::gs_ParticlesDamping, 0.1f, 2.0f);
    ImGui::SliderFloat("Particle Mass", &BodyGravityParticles::gs_ParticleMass, 1.0f, 100.0f);

    bool reInitParticlesUAVBuffer = false;
    reInitParticlesUAVBuffer |= ImGui::SliderInt("Particle Count", &(int)BodyGravityParticles::gs_ParticleCount, 10, 1000);
    reInitParticlesUAVBuffer |= ImGui::SliderFloat("Particle Spread", &BodyGravityParticles::gs_ParticleSpread, 1.0f, 100.0f);

    if (reInitParticlesUAVBuffer)
    {
        g_GfxManager.AddGraphicCommand([this] { m_InitUAVBuffer = true; });
    }
}

class GfxBodyGravityParticlesRender : public GfxRendererBase
{
public:
    void Initialize() override;
    bool ShouldPopulateCommandList(GfxContext&) const override { return BodyGravityParticles::gs_UpdateIMGUI; }
    void PopulateCommandList(GfxContext& context) override;

    const char* GetName() const override { return "GfxBodyGravityParticlesRender"; }

    GfxRootSignature* m_RootSignature = nullptr;
};

void GfxBodyGravityParticlesRender::Initialize()
{
    bbeProfileFunction();

    // Perfomance TIP: Order from most frequent to least frequent.
    CD3DX12_DESCRIPTOR_RANGE1 ranges[2]{};
    ranges[0].Init(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, 1, AutoGenerated::NBodyGravityVSPSConsts::ConstantBufferRegister, 0, D3D12_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_VOLATILE);
    ranges[1].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, AutoGenerated::NBodyGravityVSPSConsts::NbSRVs, 0, 0, D3D12_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_VOLATILE);

    m_RootSignature = g_GfxRootSignatureManager.GetOrCreateRootSig(ranges, D3D12_ROOT_SIGNATURE_FLAG_NONE, "GfxBodyGravityParticlesRender_RootSignature");
}

void GfxBodyGravityParticlesRender::PopulateCommandList(GfxContext& context)
{
    bbeProfileFunction();
    bbeProfileGPUFunction(context);

    assert(m_RootSignature);
    context.SetRootSignature(*m_RootSignature);

    // No vertex formats... we'll generate the positions of each particle quad directly in the VS via Vertex/Index IDs
    context.SetVertexFormat(GfxDefaultVertexFormats::Null);

    // Describe the blend and depth states.
    D3D12_RENDER_TARGET_BLEND_DESC blendDesc = GfxCommonStates::BlendAlphaAdditive;
    blendDesc.SrcBlendAlpha = D3D12_BLEND_ZERO;
    blendDesc.DestBlendAlpha = D3D12_BLEND_ZERO;
    context.SetBlendStates(0, blendDesc);

    // Describe the blend and depth states.
    context.SetDepthStencilStates(GfxCommonStates::DepthNone);

    AutoGenerated::NBodyGravityVSPSConsts consts;
    consts.m_ParticleRadius = 1.0f;
    context.StageCBV(consts);

}

REGISTER_RENDERER(GfxBodyGravityParticlesUpdate);
REGISTER_RENDERER(GfxBodyGravityParticlesRender);
