
void PrintToConsoleAndLogFile(const std::string& str)
{
    printf("%s\n", str.c_str());
    g_Log.info("{}", str.c_str());
}

static void OverrideExistingFileIfNecessary(const std::string& generatedString, const std::string& dirFull)
{
    // hash both existing and newly generated contents
    const std::size_t existingHash = GetFileContentsHash(dirFull);
    const std::size_t newHash = std::hash<std::string>{}(generatedString);

    // if hashes are different, over ride with new contents
    if (existingHash != newHash)
    {
        PrintToConsoleAndLogFile(StringFormat("hash different for '%s'... over-riding with new contents", dirFull.c_str()));
        const bool IsReadMode = false;
        CFileWrapper file{ dirFull, IsReadMode };
        assert(file);
        fprintf(file, "%s", generatedString.c_str());
    }
    else
    {
        PrintToConsoleAndLogFile(StringFormat("No change detected for '%s'", dirFull.c_str()));
    }
}

static void PrintShaderInputCPPFile(const ShaderInputs& inputs)
{
    std::string generatedString;
    generatedString += "#pragma once\n\n";
    generatedString += "namespace AutoGenerated {\n";
    generatedString += "\n\n";

    generatedString += StringFormat("struct %s {\n", inputs.m_Name.c_str());
    generatedString += StringFormat("    inline static const char* Name = \"%s GfxConstantBuffer\";\n", inputs.m_Name.c_str());
    generatedString += StringFormat("    static const uint32_t ConstantBufferRegister = %d;\n", inputs.m_ConstantBuffer.m_Register);
    generatedString += StringFormat("    static const uint32_t NbSRVs = %d;\n", inputs.m_Resources[SRV].size());
    generatedString += StringFormat("    static const uint32_t NbUAVs = %d;\n\n", inputs.m_Resources[UAV].size());

    // SRVs, UAVs
    auto PrintOffsetsStruct = [&inputs, &generatedString](ResourceType type)
    {
        if (inputs.m_Resources[type].size())
        {
            const char* offsetsStr = (type == SRV) ? "SRVOffsets" : "UAVOffsets";

            generatedString += StringFormat("    struct %s {\n", offsetsStr);
            for (const ShaderInputs::Resource& resource : inputs.m_Resources[type])
            {
                generatedString += StringFormat("        static const uint32_t %s = %d;\n", resource.m_Name.c_str(), resource.m_Register);
            }
            generatedString += "    };\n\n";
        }
    };

    PrintOffsetsStruct(SRV);
    PrintOffsetsStruct(UAV);

    // Constants
    for (const ShaderInputs::Constant& var : inputs.m_ConstantBuffer.m_Constants)
    {
        generatedString += StringFormat("    %s m_%s = {};\n", gs_TypesTraitsMap.at(var.m_Type).m_CPPType, var.m_Name.c_str());
    }

    generatedString += "};\n\n";

    generatedString += "\n";
    generatedString += "}\n";

    const std::string outputDir = g_Globals.m_ShadersTmpCPPShaderInputsAutogenDir + inputs.m_Name.c_str() + ".h";
    OverrideExistingFileIfNecessary(generatedString, outputDir);
}

static void PrintShaderInputHLSLFile(const ShaderInputs& inputs)
{
    std::string generatedString;

    generatedString += StringFormat("#ifndef __%s_H__\n", inputs.m_Name.c_str());
    generatedString += StringFormat("#define __%s_H__\n\n", inputs.m_Name.c_str());

    // constants struct
    generatedString += StringFormat("struct %s__Constants {\n", inputs.m_Name.c_str());
    for (const ShaderInputs::Constant& var : inputs.m_ConstantBuffer.m_Constants)
    {
        generatedString += StringFormat("    %s m_%s;\n", var.m_Type.c_str(), var.m_Name.c_str());
    }
    generatedString += "};\n\n";

    // SRVs & UAVs struct
    generatedString += StringFormat("struct %s__Resources {\n", inputs.m_Name.c_str());
    for (uint32_t i = 0; i < ResourceType_Count; ++i)
    {
        for (const ShaderInputs::Resource& resource : inputs.m_Resources[i])
        {
            generatedString += StringFormat("    %s m_%s;\n", resource.m_Type.c_str(), resource.m_Name.c_str());
        }
    }
    generatedString += "};\n\n";

    // Real struct to be referenced by user
    generatedString += StringFormat("struct %s {\n", inputs.m_Name.c_str());
    generatedString += StringFormat("    struct %s__Constants constants;\n", inputs.m_Name.c_str());
    generatedString += StringFormat("    struct %s__Resources resources;\n\n", inputs.m_Name.c_str());
    for (const ShaderInputs::Constant& var : inputs.m_ConstantBuffer.m_Constants)
    {
        generatedString += StringFormat("    %s Get%s(); { return constants.m_%s; }\n", var.m_Type.c_str(), var.m_Name.c_str(), var.m_Name.c_str());
    }
    generatedString += "\n";
    for (const ShaderInputs::Resource& resource : inputs.m_Resources[SRV])
    {
        generatedString += StringFormat("    %s Get%s() { return resources.m_%s; };\n", resource.m_Type.c_str(), resource.m_Name.c_str(), resource.m_Name.c_str());
    }
    generatedString += "};\n\n";

    // cbuffer declaration
    if (inputs.m_ConstantBuffer.m_Constants.size())
    {
        generatedString += StringFormat("cbuffer %s_cbuffer : register(b%d) { %s__Constants g_%s__Constants; }\n",
            inputs.m_Name.c_str(), inputs.m_ConstantBuffer.m_Register, inputs.m_Name.c_str(), inputs.m_Name.c_str());
    }

    // SRVs & UAVs bindings
    for (uint32_t i = 0; i < ResourceType_Count; ++i)
    {
        for (const ShaderInputs::Resource& resource : inputs.m_Resources[i])
        {
            generatedString += StringFormat("%s %s_%s : register(%s%d);\n",
                resource.m_Type.c_str(), inputs.m_Name.c_str(), resource.m_Name.c_str(), (i == SRV) ? "t" : "u", resource.m_Register);
        }
    }
    generatedString += "\n\n";

    // Helper creater function for struct
    generatedString += StringFormat("%s Create%s() {\n", inputs.m_Name.c_str(), inputs.m_Name.c_str());
    generatedString += StringFormat("    %s i\n", inputs.m_Name.c_str());
    generatedString += StringFormat("    i.constants = g_%s__Constants;\n", inputs.m_Name.c_str());
    for (const ShaderInputs::Resource& resource : inputs.m_Resources[SRV])
    {
        generatedString += StringFormat("    i.resources.m_%s = %s_%s;\n", resource.m_Name.c_str(), inputs.m_Name.c_str(), resource.m_Name.c_str());
    }
    generatedString += "    return i;\n";
    generatedString += "}\n\n";

    generatedString += StringFormat("#endif // #define __%s_H__\n", inputs.m_Name.c_str());

    const std::string outputDir = g_Globals.m_ShadersTmpHLSLAutogenDir + inputs.m_Name.c_str() + ".h";
    OverrideExistingFileIfNecessary(generatedString, outputDir);
}

void PrintAutogenFilesForShaderInput(const ShaderInputs& inputs)
{
    PrintShaderInputCPPFile(inputs);
    PrintShaderInputHLSLFile(inputs);
}

void PrintShaderPermutationStructs()
{

}

void PrintAutogenByteCodeHeadersFile()
{
    //    std::string generatedString;
    //    generatedString += "#pragma once\n\n";
    //    generatedString += "namespace AutoGenerated\n";
    //    generatedString += "{\n\n";
    //
    //    for (const ShaderCompileJob& shaderJob : g_Globals.m_AllShaderCompileJobs)
    //    {
    //        generatedString += StringFormat("#include \"%s\"\n", shaderJob.m_ShaderObjCodeFileDir.c_str());
    //    }
    //
    //    generatedString += "\n";
    //    generatedString += "struct ShaderData\n";
    //    generatedString += "{\n";
    //    generatedString += "    const unsigned char* m_ByteCodeArray;\n";
    //    generatedString += "    const uint32_t m_ByteCodeSize;\n";
    //    generatedString += "    const std::size_t m_Hash;\n";
    //    generatedString += "    const uint32_t m_ShaderKey;\n";
    //    generatedString += "    const std::size_t m_BaseShaderID;\n";
    //    generatedString += "    const GfxShaderType m_ShaderType;\n";
    //    generatedString += "};\n";
    //
    //    generatedString += "\n";
    //    generatedString += "static const ShaderData gs_AllShadersData[] = \n";
    //    generatedString += "{\n";
    //
    //    for (const ShaderCompileJob& shaderJob : g_Globals.m_AllShaderCompileJobs)
    //    {
    //        generatedString += "    {\n";
    //        generatedString += StringFormat("        %s,\n", shaderJob.m_ShaderObjCodeVarName.c_str());
    //        generatedString += StringFormat("        _countof(%s),\n", shaderJob.m_ShaderObjCodeVarName.c_str());
    //        generatedString += StringFormat("        %" PRIu64 ",\n", GetFileContentsHash(shaderJob.m_ShaderObjCodeFileDir));
    //        generatedString += StringFormat("        %u,\n", shaderJob.m_ShaderKey);
    //        generatedString += StringFormat("        %u,\n", shaderJob.m_BaseShaderID);
    //        generatedString += StringFormat("        %s,\n", EnumToString(shaderJob.m_ShaderType));
    //        generatedString += "    },\n";
    //        generatedString += "\n";
    //    }
    //    generatedString += "};\n\n";
    //
    //    generatedString += "\n";
    //    generatedString += "}\n";
    //
    //    OverrideExistingFileIfNecessary(generatedString, g_Globals.m_ShadersByteCodesDir);
}
