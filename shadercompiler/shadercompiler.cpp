
#include <graphic/dx12utils.h>

BBE_OPTIMIZE_OFF;

tf::Executor g_Executor;

static void GetHighestD3D12ShaderModel()
{
    ComPtr<IDXGIFactory7> DXGIFactory;
    DX12_CALL(CreateDXGIFactory2(0, IID_PPV_ARGS(&DXGIFactory)));

    ComPtr<IDXGIAdapter1> hardwareAdapter;
    for (UINT adapterIndex = 0; DXGIFactory->EnumAdapters1(adapterIndex, &hardwareAdapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex)
    {
        DXGI_ADAPTER_DESC1 desc{};
        hardwareAdapter->GetDesc1(&desc);

        // Don't bother with the Basic Render Driver adapter.
        if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE)
            continue;

        // we only care about D3D_FEATURE_LEVEL_1_0_CORE support
        ComPtr<ID3D12Device6> D3DDevice;
        D3D12CreateDevice(hardwareAdapter.Get(), D3D_FEATURE_LEVEL_1_0_CORE, IID_PPV_ARGS(&D3DDevice));
        assert(D3DDevice);

        for (D3D12_FEATURE_DATA_SHADER_MODEL shaderModel : gs_AllD3D12ShaderModels)
        {
            if (SUCCEEDED(D3DDevice->CheckFeatureSupport(D3D12_FEATURE_SHADER_MODEL, &shaderModel, sizeof(shaderModel))))
            {
                g_HighestD3D12ShaderModel = shaderModel.HighestShaderModel;
                PrintToConsoleAndLogFile(StringFormat("D3D12 Shader Model: %s", GetD3DShaderModelName(g_HighestD3D12ShaderModel)));
                return;
            }
        }
    }
}

//static void PrintGeneratedByteCodeHeadersFile()
//{
//    std::string generatedString;
//    generatedString += "#pragma once\n\n";
//    generatedString += "namespace AutoGenerated\n";
//    generatedString += "{\n\n";
//
//    for (const ShaderCompileJob& shaderJob : g_Globals.m_AllShaderCompileJobs)
//    {
//        generatedString += StringFormat("#include \"%s\"\n", shaderJob.m_ShaderObjCodeFileDir.c_str());
//    }
//
//    generatedString += "\n";
//    generatedString += "struct ShaderData\n";
//    generatedString += "{\n";
//    generatedString += "    const unsigned char* m_ByteCodeArray;\n";
//    generatedString += "    const uint32_t m_ByteCodeSize;\n";
//    generatedString += "    const std::size_t m_Hash;\n";
//    generatedString += "    const uint32_t m_ShaderKey;\n";
//    generatedString += "    const uint32_t m_BaseShaderID;\n";
//    generatedString += "    const GfxShaderType m_ShaderType;\n";
//    generatedString += "};\n";
//
//    generatedString += "\n";
//    generatedString += "static const ShaderData gs_AllShadersData[] = \n";
//    generatedString += "{\n";
//
//    for (const ShaderCompileJob& shaderJob : g_Globals.m_AllShaderCompileJobs)
//    {
//        generatedString += "    {\n";
//        generatedString += StringFormat("        %s,\n", shaderJob.m_ShaderObjCodeVarName.c_str());
//        generatedString += StringFormat("        _countof(%s),\n", shaderJob.m_ShaderObjCodeVarName.c_str());
//        generatedString += StringFormat("        %" PRIu64 ",\n", GetFileContentsHash(shaderJob.m_ShaderObjCodeFileDir));
//        generatedString += StringFormat("        %u,\n", shaderJob.m_ShaderKey);
//        generatedString += StringFormat("        %u,\n", shaderJob.m_BaseShaderID);
//        generatedString += StringFormat("        %s,\n", EnumToString(shaderJob.m_ShaderType));
//        generatedString += "    },\n";
//        generatedString += "\n";
//    }
//    generatedString += "};\n\n";
//
//    generatedString += "\n";
//    generatedString += "}\n";
//
//    OverrideExistingFileIfNecessary(generatedString, g_Globals.m_ShadersByteCodesDir);
//}
//
//static void PrintShaderPermutationStructs()
//{
//    for (const ShaderPermutationsPrintJob& job : g_Globals.m_AllShaderPermutationsPrintJobs)
//    {
//        std::string generatedString;
//        generatedString += "#pragma once\n\n";
//        generatedString += "namespace Shaders\n";
//        generatedString += "{\n\n";
//
//        generatedString += StringFormat("struct %sPermutations\n", job.m_BaseShaderName.c_str());
//        generatedString += "{\n";
//
//        generatedString += "    union\n";
//        generatedString += "    {\n";
//        generatedString += "        struct\n";
//        generatedString += "        {\n";
//        for (const std::string& permutationString : job.m_Defines)
//        {
//            generatedString += StringFormat("           bool %s : 1;\n", permutationString.c_str());
//        }
//        generatedString += "        };\n";
//        generatedString += "        uint32_t m_ShaderKey = 0;\n";
//        generatedString += "    };\n\n";
//        generatedString += "private:\n";
//        generatedString += StringFormat("    static const uint32_t BaseShaderID = %u;\n", job.m_BaseShaderID);
//        generatedString += StringFormat("    static const GfxShaderType ShaderType = %s;\n", EnumToString(job.m_ShaderType));
//        generatedString += "\n";
//        generatedString += "    friend class GfxShaderManager;\n";
//
//        generatedString += "};\n";
//
//        generatedString += "\n";
//        generatedString += "}\n";
//
//
//        const std::string outputDir = g_Globals.m_ShadersTmpCPPAutogenDir + job.m_BaseShaderName + ".h";
//        OverrideExistingFileIfNecessary(generatedString, outputDir);
//    }
//}

struct GlobalsInitializer
{
    GlobalsInitializer()
    {
        // init dirs
        g_Globals.m_AppDir                                    = GetApplicationDirectory();
        g_Globals.m_ShadersJSONDir                            = g_Globals.m_AppDir + "..\\shadercompiler\\shaders";
        g_Globals.m_ShadersTmpDir                             = g_Globals.m_AppDir + "..\\tmp\\shaders\\";
        g_Globals.m_ShadersTmpHLSLAutogenDir                  = g_Globals.m_ShadersTmpDir + "autogen\\hlsl\\";
        g_Globals.m_ShadersTmpCPPShaderInputsAutogenDir       = g_Globals.m_ShadersTmpDir + "autogen\\cpp\\ShaderInputs\\";
        g_Globals.m_ShadersTmpCPPShaderPermutationsAutogenDir = g_Globals.m_ShadersTmpDir + "autogen\\cpp\\ShaderPermutations\\";
        g_Globals.m_ShadersDir                                = g_Globals.m_AppDir + "..\\src\\graphic\\shaders\\";
        g_Globals.m_ShadersByteCodesDir                       = g_Globals.m_ShadersTmpDir + "shaderbytecodes.h";
        g_Globals.m_DXCDir                                    = g_Globals.m_AppDir + "..\\extern\\dxc\\dxc.exe";

        CreateDirectory(StringFormat("%s..\\tmp", g_Globals.m_AppDir.c_str()).c_str(), nullptr);
        CreateDirectory(g_Globals.m_ShadersTmpDir.c_str(), nullptr);
        CreateDirectory((g_Globals.m_ShadersTmpDir + "autogen\\").c_str(), nullptr);
        CreateDirectory(g_Globals.m_ShadersTmpHLSLAutogenDir.c_str(), nullptr);
        CreateDirectory(g_Globals.m_ShadersTmpCPPShaderInputsAutogenDir.c_str(), nullptr);
        CreateDirectory(g_Globals.m_ShadersTmpCPPShaderPermutationsAutogenDir.c_str(), nullptr);
    }
};
static const GlobalsInitializer g_GlobalsInitializer;

int main()
{
    // first, Init the logger
    Logger::GetInstance().Initialize("../bin/shadercompiler_output.txt");

    std::vector<std::string> allJSONs;
    GetFilesInDirectory(allJSONs, g_Globals.m_ShadersJSONDir);

    concurrency::concurrent_vector<Shader> allShaders;
    for (const std::string& file : allJSONs)
    {
        PrintToConsoleAndLogFile(StringFormat("Processing '%s'...", GetFileNameFromPath(file).c_str()));

        CFileWrapper jsonFile{ file.c_str() };

        try
        {
            json baseJSON = json::parse(jsonFile);

            if (baseJSON.contains("Shader"))
            {
                Shader& newShader = *allShaders.push_back(Shader{});

                json shaderJSON = baseJSON.at("Shader");
                newShader.m_Name = shaderJSON.at("ShaderName");
                newShader.m_FileName = shaderJSON.at("FileName");

                // Add entry points
                auto AddEntryPoint = [&shaderJSON, &newShader](GfxShaderType shaderType)
                {
                    const std::string entryPointName = std::string{ EnumToString(shaderType) } + "EntryPoint";
                    if (shaderJSON.contains(entryPointName.c_str()))
                    {
                        newShader.m_EntryPoints[shaderType] = shaderJSON.at(entryPointName.c_str());
                        newShader.m_Permutations[shaderType].push_back("");
                    }
                };
                AddEntryPoint(VS);
                AddEntryPoint(PS);
                AddEntryPoint(CS);

                // add Shader Permutations
                if (shaderJSON.contains("ShaderPermutations"))
                {
                    auto AddPermutations = [&shaderJSON, &newShader](GfxShaderType shaderType)
                    {
                        json shaderPermsJSON = shaderJSON.at("ShaderPermutations");
                        const char* shaderTypeStr = EnumToString(shaderType);
                        if (shaderPermsJSON.contains(shaderTypeStr))
                        {
                            json shaderPermsForTypeJSON = shaderPermsJSON.at(shaderTypeStr);
                            for (const json permutation : shaderPermsForTypeJSON.at("Defines"))
                            {
                                newShader.m_Permutations[shaderType].push_back(permutation.get<std::string>());
                            }

                            // TODO
                            if (shaderPermsForTypeJSON.contains("Rules"))
                            {

                            }
                        }
                    };
                    AddPermutations(VS);
                    AddPermutations(PS);
                    AddPermutations(CS);
                }

                for (uint32_t i = 0; i < NbShaderTypes; ++i)
                {
                    if (newShader.m_Permutations[i].size())
                        PrintToConsoleAndLogFile(StringFormat("Shader: '%s_%s': %d Unfiltered Permutations", EnumToString((GfxShaderType)i), newShader.m_Name.c_str(), newShader.m_Permutations[i].size()));
                }
            }

            for (json shaderInput : baseJSON.at("ShaderInputs"))
            {
                ShaderInputs inputs{ shaderInput.at("Name") };

                // Constant Buffer
                if (shaderInput.contains("ConstantBuffer"))
                {
                    json cBufferJSON = shaderInput.at("ConstantBuffer");
                    inputs.m_ConstantBuffer.m_Register = cBufferJSON.at("Register");

                    uint32_t totalBytes = 0;
                    for (json constantJSON : cBufferJSON.at("Constants"))
                    {
                        inputs.m_ConstantBuffer.m_Constants.push_back({ constantJSON.at("Type"), constantJSON.at("Name") });
                        totalBytes += g_TypesTraitsMap.at(inputs.m_ConstantBuffer.m_Constants.back().m_Type).m_SizeInBytes;
                    }

                    // Add padding if necessary
                    const uint32_t numPadVars = (AlignUp(totalBytes, 16) - totalBytes) / sizeof(uint32_t);
                    for (uint32_t i = 0; i < numPadVars; ++i)
                    {
                        inputs.m_ConstantBuffer.m_Constants.push_back({ "uint", StringFormat("PADDING_%d", i).c_str() });
                    }
                }

                // SRVs, UAVs
                if (shaderInput.contains("Resources"))
                {
                    json resourcesJSON = shaderInput.at("Resources");
                    for (json resource : resourcesJSON)
                    {
                        const std::string& resourceTypeStr = resource.at("Type");
                        const ResourceType resourceType = g_ResourceTraitsMap.at(resourceTypeStr).m_Type;

                        inputs.m_Resources[resourceType].push_back({ resourceTypeStr, resource.at("Register"), resource.at("Name") });
                    }
                }

                PrintAutogenFilesForShaderInput(inputs);
            }
        }
        catch (const std::exception& e)
        {
            PrintToConsoleAndLogFile(e.what());
            assert(false);
        }
    }

    tf::Taskflow getShaderModelTF;
    getShaderModelTF.emplace([]() { GetHighestD3D12ShaderModel(); });
    std::future<void> getShaderModelFuture = g_Executor.run(getShaderModelTF);

    //// get each shader to populate g_AllShaderCompileJobs
    //{
    //    tf::Taskflow tf;

    //    for (const auto& func : g_Globals.m_JobsPopulators)
    //    {
    //        tf.emplace([&]() { func(); });
    //    }
    //    g_Executor.run(tf).wait();
    //}

    //// print auto-gen constant buffer headers
    //{
    //    tf::Taskflow tf;

    //    tf.for_each(g_Globals.m_AllConstantBuffers.begin(), g_Globals.m_AllConstantBuffers.end(), [&](ConstantBuffer& cb)
    //        {
    //            PrintAutogenFilesForCBs(cb);
    //        });

    //    // sort the container, so that it always produces consistent auto-gen files
    //    tf.emplace([&]()
    //        {
    //            std::sort(g_Globals.m_AllShaderCompileJobs.begin(), g_Globals.m_AllShaderCompileJobs.end(), [&](const ShaderCompileJob& lhs, ShaderCompileJob& rhs)
    //                {
    //                    return lhs.m_BaseShaderName < rhs.m_BaseShaderName;
    //                });
    //        });

    //    g_Executor.run(tf).wait();
    //}

     // Must wait for d3d12 shader model to be retrieved first before we schedule the jobs
     getShaderModelFuture.wait();

    //// run all jobs in g_AllShaderCompileJobs
    //{
    //    tf::Taskflow tf;

    //    tf.for_each(g_Globals.m_AllShaderCompileJobs.begin(), g_Globals.m_AllShaderCompileJobs.end(), [&](ShaderCompileJob& shaderJob)
    //        {
    //            shaderJob.StartJob();
    //        });

    //    g_Executor.run(tf).wait();
    //}

    //if (g_CompileFailureDetected)
    //{
    //    PrintToConsoleAndLogFile("Compile failure(s) detected!\n\n");
    //}
    //else
    //{
    //    PrintGeneratedByteCodeHeadersFile();
    //    PrintShaderPermutationStructs();
    //}

    system("pause");
    return 0;
}
